import glob
import os
import numpy as np
import math
from PIL import Image
from bs4 import BeautifulSoup

# variables
stride = 256 # int step size to take between subsequent images
patchsize = 256 # int size to split image 

'''
takes a whole image and splits it into patchsize x patchsize squares by stride step amount
will ignore patches that extend beyond original images borders, even partly
stride: int number of pixels between start of each following patch
patchsize: int pixel size of patch, assumes square (nxn)
imgdir: string directory of where the original whole images are
savedir: string directory of where the patches are to be saved
'''
def splitimage(stride, patchsize, imgdir, savedir):

    Image.MAX_IMAGE_PIXELS = None # to avoid image size warning
    
    imglist = [f for f in glob.glob("./"+imgdir+"/**.jpeg", recursive=False)] # set directory of where whole images are

    patchnum = 1

    for image in imglist: # open images
        img = Image.open(image)
        width, height = img.size

        for col_i in range(0, width, stride): # loop over size of image, going down and then to the right in that order
            for row_i in range(0, height, stride):
                if ((col_i + patchsize > width) or (row_i + patchsize > height)): # if split would extend beyond bounds of original image, skip
                    # frame_num += 1 (add to preserve numbering)
                    break
                    
                crop = img.crop((col_i, row_i, col_i + patchsize, row_i + patchsize))
                name = os.path.basename(image)
                name = os.path.splitext(name)[0]
                save_to= os.path.join(savedir, name+"_{:01}.png") # save image appended with patchnum
                crop.save(save_to.format(patchnum))
                patchnum += 1

'''
# Calculate number of rows and columns each image is split into based on width & height, store in array indexed by image number
# stride: number of pixels between start of each following patch
# patchsize: pixel size of patch, assumes square (nxn)
# imgdir: string directory of where the original whole images are
'''
def numRowsCols(stride, patchsize, imgdir):
    
    imagelist = [f for f in glob.glob("./"+imgdir+"/**.jpeg", recursive=False)] # creates list of all jpeg images in dir
    
    i = 0
    numImages = len(imagelist)

    numCols = np.empty(numImages, dtype=object)
    numRows = np.empty(numImages, dtype=object)

    for image in imagelist: # open images, get # of rows and columns of patches per image, store in arrays
        img = Image.open(image)
        width, height = img.size
    
        numCols[i] = math.floor((width - patchsize)/stride) + 1
        numRows[i] = math.floor((height - patchsize)/stride) + 1
        
        i += 1
        
    return numRows, numCols

'''
# open xmls, store bounding box coordinates in temporary arrays to be used in calculation later
# xmldir: string directory of where xml files are
# savedir: string directory of where to save npy arrays for bounding boxes
'''
def npyfromxml(xmldir, savedir):

    xmllist = [f for f in glob.glob("./"+xmldir+"/**.xml", recursive=False)] # creates list of all xml files in dir

    j = 0

    for xml in xmllist: # open xmls, store bbs in temp arrays
    
        boundboxarray = np.empty(0) # initializes array / resets array when moving on to next xml
    
        with open(xml) as fp: #open each individual file
            soup = BeautifulSoup(fp, "xml", multi_valued_attributes=None)
            soup = soup.find_all('bndbox')
        
            for bndbox in soup: # find all tags "bndbox" and get dimensions, store in numpy array
                res = [int(i) for i in bndbox.get_text().split() if i.isdigit()]
                res = np.array(res)
                res = np.expand_dims(res, axis=0)

                if (boundboxarray.shape == (0,)): # 1st pass through, creates 1st element
                    boundboxarray = res 
                else: # all other passes through, concatenates by adding along bottom
                    boundboxarray = np.concatenate((boundboxarray, res), axis = 0)
                
            np.save("./"+savedir+"/array_"+str(j)+".npy", boundboxarray)
        
            j += 1

'''
# open patches and npy arrays corresponding to full image, calculate new coords of bbs with respect to patch, append to new npy array
# stride: number of pixels between start of each following patch
# patchsize: pixel size of patch, assumes square (nxn)
# usedRows / usedCols: vectors containing number of rows/cols of patches generated per image, generated by function numRowsCols
# arraydir: string directory of where the old npy files are
# savedir: string directory of where the new npy files are to be saved
'''
def newfromoldnpy(stride, patchsize, usedRows, usedCols, arraydir, savedir):
    
    import glob
    import numpy as np
    
    arraylist = [f for f in glob.glob("./"+arraydir+"/**.npy", recursive=False)]
    arrayiter = iter(arraylist)

    l = 0 # 0 to (number of npy arrays/images - 1)
    currpatchnum = 1 # 1 to current patch, resets when moving to next whole image
    totpatchnum = 1 # 1 to total number of patches

    for p in range(len(arraylist)):
        bbarray = next(arrayiter)

        with open(bbarray, 'rb') as array:
            bbs = np.load(array)
        
            bbnum, _ = bbs.shape # get number of bounding boxes for specific whole image

        for m in range(usedCols[l]): # loop over columns and rows of patches for each image/npy array
            for n in range(usedRows[l]):
                newarray = np.empty(0) # initializes array / resets array when moving on to next patch
        
                x = m * stride
                y = n * stride
            
                for q in range(bbnum): # loop over number of bounding boxes per image
                    if ( (bbs[q, 0] >= (x + patchsize) ) or (bbs[q, 2] <= x) ):
                        continue # skip iteration if xmin above patch max x, or if xmax below patch min x
        
                    if ( (bbs[q, 1] >= (y + patchsize) ) or (bbs[q, 3] <= y) ):
                        continue # skip iteration if ymin above patch max y, or if ymax below patch min y
        
                    if bbs[q, 2] >= (x + patchsize): # if xmax above max dimension, set equal to patchsize
                        bbs[q, 2] = patchsize
                    else: # if xmax between x and x + patchsize, normalize to between 0 and patchsize
                        bbs[q, 2] = bbs[q, 2] - x
        
                    if bbs[q, 0] <= (x): # if xmin below min dimension, set equal to 0
                        bbs[q, 0] = 0
                    else: # if xmin between x and x + patchsize, normalize to between 0 and patchsize
                        bbs[q, 0] = bbs[q, 0] - x
                        
                    if bbs[q, 3] >= (y + patchsize): # if ymax above max dimension, set equal to patchsize
                        bbs[q, 3] = patchsize
                    else: # if ymax between y and y + patchsize, normalize to between 0 and patchsize
                        bbs[q, 3] = bbs[q, 3] - y
        
                    if bbs[q, 1] <= (y): # if ymin below min dimension, set equal to 0
                        bbs[q, 1] = 0   
                    else: # if ymin between y and y + patchsize, normalize to between 0 and patchsize
                        bbs[q, 1] = bbs[q, 1] - y
                    
                    if (newarray.shape == (0,)): # 1st pass through, creates 1st element
                        newarray = np.array(bbs[q, :])
                        newarray = np.expand_dims(newarray, axis=0)
                    else: # all other passes through, concatenates by adding along bottom
                        temparray = np.array(bbs[q, :])
                        newarray = np.concatenate((newarray, np.expand_dims(temparray, axis=0)), axis = 0)
                        
                if (newarray.shape != (0,)): # if new array is not blank, save corresponding to patch
                    np.save("./"+savedir+"/array_patch_"+str(totpatchnum)+".npy", newarray)
                
                currpatchnum += 1
                totpatchnum += 1
            
        if (currpatchnum == usedCols[l] * usedRows[l] + 1): # if patchnumber gets above current number of patches, move on to next set of patches
            l += 1
            currpatchnum = 1

def main():
    # usage of functions
    splitimage(256, 256, "sig-train-pos", "sig-train-pos-split")
    usedRows, usedCols = numRowsCols(256, 256, "sig-train-pos")
    npyfromxml("sig-train-pos", "npy-before-split")
    newfromoldnpy(256, 256, usedRows, usedCols, "npy-before-split", "npy-after-split")

if __name__ == "__main__":
    main()